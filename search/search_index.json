{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"declare4pylon","text":"<p>DECLARE constraints implementation for pylon-lib.</p>"},{"location":"declare4pylon/","title":"Declare4Pylon","text":""},{"location":"declare4pylon/#declare4pylon.DeclareConstraintLoss","title":"<code>DeclareConstraintLoss</code>","text":"<p>A class that wraps a constraint and provides a callable interface for evaluating it.</p> <pre><code>logic_expression (LogicExpression): The logic expression to evaluate.\nsolver (Solver): The solver to use for the constraint.\n</code></pre>"},{"location":"declare4pylon/#declare4pylon.DeclareConstraintLoss--example","title":"Example:","text":"<pre><code>&gt;&gt;&gt; from declare4pylon import DeclareConstraintLoss\n&gt;&gt;&gt; from pylon.solver import WeightedSamplingSolver\n&gt;&gt;&gt; from declare4pylon import ExistenceConstraint\n&gt;&gt;&gt;\n&gt;&gt;&gt; constraint_loss = DeclareConstraintLoss(\n...     ExistenceConstraint(activity=1, count=1),\n...     WeightedSamplingSolver(num_samples=1),\n... )\n&gt;&gt;&gt;\n&gt;&gt;&gt; logits = torch.rand(2, 3, 4)\n&gt;&gt;&gt; loss = constraint_loss(logits)\n</code></pre> Source code in <code>src/declare4pylon/declare_constraint_loss.py</code> <pre><code>class DeclareConstraintLoss:\n    \"\"\"A class that wraps a constraint and provides a callable interface for evaluating it.\n\n    Args:\n    ----\n        logic_expression (LogicExpression): The logic expression to evaluate.\n        solver (Solver): The solver to use for the constraint.\n\n    Example:\n    -------\n        &gt;&gt;&gt; from declare4pylon import DeclareConstraintLoss\n        &gt;&gt;&gt; from pylon.solver import WeightedSamplingSolver\n        &gt;&gt;&gt; from declare4pylon import ExistenceConstraint\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; constraint_loss = DeclareConstraintLoss(\n        ...     ExistenceConstraint(activity=1, count=1),\n        ...     WeightedSamplingSolver(num_samples=1),\n        ... )\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; logits = torch.rand(2, 3, 4)\n        &gt;&gt;&gt; loss = constraint_loss(logits)\n\n    \"\"\"\n\n    def __init__(self, logic_expression: LogicExpression, solver: Solver) -&gt; None:\n        \"\"\"Initialize the DeclareConstraintLoss.\n\n        Args:\n        ----\n            logic_expression (LogicExpression): The logic expression to evaluate.\n            solver (Solver): The solver to use for the constraint.\n\n        Raises:\n        ------\n            TypeError: If logic_expression is not of type :class:`~declare4pylon.LogicExpression`\n                or if solver is not of type `pylon.solver.Solver`.\n\n        \"\"\"\n        if not isinstance(logic_expression, LogicExpression):\n            msg = f\"Expected logic_expression to be of type LogicExpression, but got {type(logic_expression)}\"\n            raise TypeError(msg)\n        if not isinstance(solver, Solver):\n            msg = f\"Expected solver to be of type Solver, but got {type(solver)}\"\n            raise TypeError(msg)\n        self.logic_expression = logic_expression\n\n        self._constraint = constraint(\n            cond=self._wrapper,\n            solver=solver,\n        )\n\n    def __call__(\n        self,\n        logits: Float[torch.Tensor, \"batch classes logits\"],\n        *,\n        prefixes: Int[torch.Tensor, \"batch prefix\"] | None = None,\n    ) -&gt; Float[torch.Tensor, \"\"]:\n        \"\"\"Evaluate the constraint.\n\n        Args:\n        ----\n            logits (Float[torch.Tensor, \"batch classes logits\"]): The logits to evaluate.\n            prefixes (Int[torch.Tensor, \"batch prefix\"], optional): Optional prefixes to prepend to the traces.\n                Defaults to None.\n\n        Returns:\n        -------\n            Float[torch.Tensor, \"\"]: The loss value.\n\n        \"\"\"\n        return self._constraint(logits, prefixes=prefixes)  # type: ignore[no-any-return]\n\n    def _wrapper(self, traces: torch.Tensor, kwargs: dict) -&gt; Float[torch.Tensor, \"\"]:\n        if kwargs.get(\"prefixes\") is not None:\n            prefixes = kwargs[\"prefixes\"]\n            traces = torch.cat([prefixes, traces], dim=1)\n        return self.logic_expression.evaluate(traces)\n</code></pre>"},{"location":"declare4pylon/#declare4pylon.DeclareConstraintLoss.__call__","title":"<code>__call__(logits, *, prefixes=None)</code>","text":"<p>Evaluate the constraint.</p> <pre><code>logits (Float[torch.Tensor, \"batch classes logits\"]): The logits to evaluate.\nprefixes (Int[torch.Tensor, \"batch prefix\"], optional): Optional prefixes to prepend to the traces.\n    Defaults to None.\n</code></pre> <pre><code>Float[torch.Tensor, \"\"]: The loss value.\n</code></pre> Source code in <code>src/declare4pylon/declare_constraint_loss.py</code> <pre><code>def __call__(\n    self,\n    logits: Float[torch.Tensor, \"batch classes logits\"],\n    *,\n    prefixes: Int[torch.Tensor, \"batch prefix\"] | None = None,\n) -&gt; Float[torch.Tensor, \"\"]:\n    \"\"\"Evaluate the constraint.\n\n    Args:\n    ----\n        logits (Float[torch.Tensor, \"batch classes logits\"]): The logits to evaluate.\n        prefixes (Int[torch.Tensor, \"batch prefix\"], optional): Optional prefixes to prepend to the traces.\n            Defaults to None.\n\n    Returns:\n    -------\n        Float[torch.Tensor, \"\"]: The loss value.\n\n    \"\"\"\n    return self._constraint(logits, prefixes=prefixes)  # type: ignore[no-any-return]\n</code></pre>"},{"location":"declare4pylon/#declare4pylon.DeclareConstraintLoss.__init__","title":"<code>__init__(logic_expression, solver)</code>","text":"<p>Initialize the DeclareConstraintLoss.</p> <pre><code>logic_expression (LogicExpression): The logic expression to evaluate.\nsolver (Solver): The solver to use for the constraint.\n</code></pre> <pre><code>TypeError: If logic_expression is not of type :class:`~declare4pylon.LogicExpression`\n    or if solver is not of type `pylon.solver.Solver`.\n</code></pre> Source code in <code>src/declare4pylon/declare_constraint_loss.py</code> <pre><code>def __init__(self, logic_expression: LogicExpression, solver: Solver) -&gt; None:\n    \"\"\"Initialize the DeclareConstraintLoss.\n\n    Args:\n    ----\n        logic_expression (LogicExpression): The logic expression to evaluate.\n        solver (Solver): The solver to use for the constraint.\n\n    Raises:\n    ------\n        TypeError: If logic_expression is not of type :class:`~declare4pylon.LogicExpression`\n            or if solver is not of type `pylon.solver.Solver`.\n\n    \"\"\"\n    if not isinstance(logic_expression, LogicExpression):\n        msg = f\"Expected logic_expression to be of type LogicExpression, but got {type(logic_expression)}\"\n        raise TypeError(msg)\n    if not isinstance(solver, Solver):\n        msg = f\"Expected solver to be of type Solver, but got {type(solver)}\"\n        raise TypeError(msg)\n    self.logic_expression = logic_expression\n\n    self._constraint = constraint(\n        cond=self._wrapper,\n        solver=solver,\n    )\n</code></pre>"},{"location":"declare4pylon/#declare4pylon.LogicExpression","title":"<code>LogicExpression</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for logic expressions.</p> <p>This class defines the interface for logic expressions used in the Declare4Pylon library. Subclasses must implement the <code>_condition</code> method to define the specific logic expression.</p> <p>The class provides an <code>evaluate</code> method that applies the logic expression to a batch of traces.</p> Source code in <code>src/declare4pylon/logic_expression.py</code> <pre><code>class LogicExpression(ABC):\n    \"\"\"Abstract base class for logic expressions.\n\n    This class defines the interface for logic expressions used in the Declare4Pylon library.\n    Subclasses must implement the `_condition` method to define the specific logic expression.\n\n    The class provides an `evaluate` method that applies the logic expression to a batch of traces.\n    \"\"\"\n\n    def evaluate(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        \"\"\"Evaluate the logic expression on the given traces.\n\n        Args:\n        ----\n            traces (Int[torch.Tensor, \"batch activities\"]): The traces to evaluate.\n\n        Returns:\n        -------\n            Bool[torch.Tensor, \" batch\"]: The result of the evaluation.\n\n        \"\"\"\n        return self._condition(traces)\n\n    @abstractmethod\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        pass\n</code></pre>"},{"location":"declare4pylon/#declare4pylon.LogicExpression.evaluate","title":"<code>evaluate(traces)</code>","text":"<p>Evaluate the logic expression on the given traces.</p> <pre><code>traces (Int[torch.Tensor, \"batch activities\"]): The traces to evaluate.\n</code></pre> <pre><code>Bool[torch.Tensor, \" batch\"]: The result of the evaluation.\n</code></pre> Source code in <code>src/declare4pylon/logic_expression.py</code> <pre><code>def evaluate(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n    \"\"\"Evaluate the logic expression on the given traces.\n\n    Args:\n    ----\n        traces (Int[torch.Tensor, \"batch activities\"]): The traces to evaluate.\n\n    Returns:\n    -------\n        Bool[torch.Tensor, \" batch\"]: The result of the evaluation.\n\n    \"\"\"\n    return self._condition(traces)\n</code></pre>"},{"location":"declare4pylon/operators/","title":"Operators","text":""},{"location":"declare4pylon/operators/#declare4pylon.operators.BinaryAnd","title":"<code>BinaryAnd</code>","text":"<p>               Bases: <code>BinaryOperator</code></p> <p>Binary operator to combine two <code>LogicExpression</code> using logical AND.</p> Source code in <code>src/declare4pylon/operators/binary/binary_and.py</code> <pre><code>class BinaryAnd(BinaryOperator):\n    \"\"\"Binary operator to combine two `LogicExpression` using logical AND.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_and(\n            self.left.evaluate(traces),\n            self.right.evaluate(traces),\n        )\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.BinaryOperator","title":"<code>BinaryOperator</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Abstract class for binary operators.</p> <p>This class represents a binary operator that operates on two operands. The operands must be instances of LogicExpression. This class is intended to be subclassed by specific binary operator implementations. It is not meant to be instantiated directly.</p> Source code in <code>src/declare4pylon/operators/binary/binary_operator.py</code> <pre><code>class BinaryOperator(Operator):\n    \"\"\"Abstract class for binary operators.\n\n    This class represents a binary operator that operates on two operands.\n    The operands must be instances of LogicExpression.\n    This class is intended to be subclassed by specific binary operator implementations.\n    It is not meant to be instantiated directly.\n    \"\"\"\n\n    def __init__(self, left: LogicExpression, right: LogicExpression) -&gt; None:\n        \"\"\"Initialize a binary operator.\n\n        Args:\n        ----\n            left (LogicExpression): The left operand.\n            right (LogicExpression): The right operand.\n\n        \"\"\"\n        self.left = left\n        self.right = right\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.BinaryOperator.__init__","title":"<code>__init__(left, right)</code>","text":"<p>Initialize a binary operator.</p> <pre><code>left (LogicExpression): The left operand.\nright (LogicExpression): The right operand.\n</code></pre> Source code in <code>src/declare4pylon/operators/binary/binary_operator.py</code> <pre><code>def __init__(self, left: LogicExpression, right: LogicExpression) -&gt; None:\n    \"\"\"Initialize a binary operator.\n\n    Args:\n    ----\n        left (LogicExpression): The left operand.\n        right (LogicExpression): The right operand.\n\n    \"\"\"\n    self.left = left\n    self.right = right\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.BinaryOr","title":"<code>BinaryOr</code>","text":"<p>               Bases: <code>BinaryOperator</code></p> <p>Binary operator to combine two <code>LogicExpression</code> using logical OR.</p> Source code in <code>src/declare4pylon/operators/binary/binary_or.py</code> <pre><code>class BinaryOr(BinaryOperator):\n    \"\"\"Binary operator to combine two `LogicExpression` using logical OR.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_or(\n            self.left.evaluate(traces),\n            self.right.evaluate(traces),\n        )\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.Operator","title":"<code>Operator</code>","text":"<p>               Bases: <code>LogicExpression</code></p> <p>Base class for all operators.</p> Source code in <code>src/declare4pylon/operators/operator.py</code> <pre><code>class Operator(LogicExpression):\n    \"\"\"Base class for all operators.\"\"\"\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.UnaryNot","title":"<code>UnaryNot</code>","text":"<p>               Bases: <code>UnaryOperator</code></p> <p>Unary operator to negate the result of a <code>LogicExpression</code>.</p> Source code in <code>src/declare4pylon/operators/unary/unary_not.py</code> <pre><code>class UnaryNot(UnaryOperator):\n    \"\"\"Unary operator to negate the result of a `LogicExpression`.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_not(self.operand.evaluate(traces))\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.UnaryOperator","title":"<code>UnaryOperator</code>","text":"<p>               Bases: <code>Operator</code></p> <p>Base class for unary operators.</p> <p>This class represents a unary operator that operates on a single operand. The operand must be an instance of LogicExpression. This class is intended to be subclassed by specific unary operator implementations. It is not meant to be instantiated directly.</p> Source code in <code>src/declare4pylon/operators/unary/unary_operator.py</code> <pre><code>class UnaryOperator(Operator):\n    \"\"\"Base class for unary operators.\n\n    This class represents a unary operator that operates on a single operand.\n    The operand must be an instance of LogicExpression.\n    This class is intended to be subclassed by specific unary operator implementations.\n    It is not meant to be instantiated directly.\n    \"\"\"\n\n    def __init__(self, operand: LogicExpression) -&gt; None:\n        \"\"\"Initialize a UnaryOperator.\n\n        Args:\n        ----\n            operand (LogicExpression): The operand for the unary operator.\n\n        \"\"\"\n        self.operand = operand\n</code></pre>"},{"location":"declare4pylon/operators/#declare4pylon.operators.UnaryOperator.__init__","title":"<code>__init__(operand)</code>","text":"<p>Initialize a UnaryOperator.</p> <pre><code>operand (LogicExpression): The operand for the unary operator.\n</code></pre> Source code in <code>src/declare4pylon/operators/unary/unary_operator.py</code> <pre><code>def __init__(self, operand: LogicExpression) -&gt; None:\n    \"\"\"Initialize a UnaryOperator.\n\n    Args:\n    ----\n        operand (LogicExpression): The operand for the unary operator.\n\n    \"\"\"\n    self.operand = operand\n</code></pre>"},{"location":"declare4pylon/constraints/choice/","title":"Choice","text":""},{"location":"declare4pylon/constraints/choice/#declare4pylon.constraints.choice.ChoiceConstraint","title":"<code>ChoiceConstraint</code>","text":"<p>               Bases: <code>ChoiceTemplate</code></p> <p>Activity A or B eventually occur in the process instance.</p> Source code in <code>src/declare4pylon/constraints/choice/choice.py</code> <pre><code>class ChoiceConstraint(ChoiceTemplate):\n    \"\"\"Activity A or B eventually occur in the process instance.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.any(traces == self.activity_a, dim=1) | torch.any(traces == self.activity_b, dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/choice/#declare4pylon.constraints.choice.ChoiceTemplate","title":"<code>ChoiceTemplate</code>","text":"<p>               Bases: <code>DeclareConstraint</code></p> <p>Base class for choice constraints.</p> <p>This class is used as a template for defining choice constraints in the Declare4Pylon library. It is not intended to be used directly, but rather as a base class for specific choice constraints.</p> Source code in <code>src/declare4pylon/constraints/choice/template.py</code> <pre><code>class ChoiceTemplate(DeclareConstraint):\n    \"\"\"Base class for choice constraints.\n\n    This class is used as a template for defining choice constraints in the\n    Declare4Pylon library.\n    It is not intended to be used directly, but rather as a base class for\n    specific choice constraints.\n    \"\"\"\n\n    def __init__(self, activity_a: int, activity_b: int) -&gt; None:\n        \"\"\"Initialize the ChoiceTemplate with two activities.\n\n        Args:\n        ----\n            activity_a (int): The first activity to be used in the choice constraint.\n            activity_b (int): The second activity to be used in the choice constraint.\n\n\n        \"\"\"\n        self.activity_a = activity_a\n        self.activity_b = activity_b\n</code></pre>"},{"location":"declare4pylon/constraints/choice/#declare4pylon.constraints.choice.ChoiceTemplate.__init__","title":"<code>__init__(activity_a, activity_b)</code>","text":"<p>Initialize the ChoiceTemplate with two activities.</p> <pre><code>activity_a (int): The first activity to be used in the choice constraint.\nactivity_b (int): The second activity to be used in the choice constraint.\n</code></pre> Source code in <code>src/declare4pylon/constraints/choice/template.py</code> <pre><code>def __init__(self, activity_a: int, activity_b: int) -&gt; None:\n    \"\"\"Initialize the ChoiceTemplate with two activities.\n\n    Args:\n    ----\n        activity_a (int): The first activity to be used in the choice constraint.\n        activity_b (int): The second activity to be used in the choice constraint.\n\n\n    \"\"\"\n    self.activity_a = activity_a\n    self.activity_b = activity_b\n</code></pre>"},{"location":"declare4pylon/constraints/choice/#declare4pylon.constraints.choice.ExclusiveChoiceConstraint","title":"<code>ExclusiveChoiceConstraint</code>","text":"<p>               Bases: <code>ChoiceTemplate</code></p> <p>Activity A or B eventually occur in the process instance, but not together.</p> Source code in <code>src/declare4pylon/constraints/choice/exclusive_choice.py</code> <pre><code>class ExclusiveChoiceConstraint(ChoiceTemplate):\n    \"\"\"Activity A or B eventually occur in the process instance, but not together.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.any(traces == self.activity_a, dim=1) ^ torch.any(traces == self.activity_b, dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/existence/","title":"Existence","text":""},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.AbsenceConstraint","title":"<code>AbsenceConstraint</code>","text":"<p>               Bases: <code>ExistenceTemplateWithCount</code></p> <p>A class used to represent the absence of an activity in traces.</p> <p>This constraint states that a certain activity must not occur in the traces. It is defined by the activity to be checked and a count. The count specifies the threshold at which the activity is considered absent. E.g. if the count is 1, the activity must not occur at all in the traces. If the count is not provided, it defaults to 1.</p> <pre><code>activity (int): The activity to be checked.\ncount (int, optional): The threshold at which the activity is considered absent.\n    Defaults to 1.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/absence.py</code> <pre><code>class AbsenceConstraint(ExistenceTemplateWithCount):\n    \"\"\"A class used to represent the absence of an activity in traces.\n\n    This constraint states that a certain activity must not occur in the traces.\n    It is defined by the activity to be checked and a count.\n    The count specifies the threshold at which the activity is considered absent.\n    E.g. if the count is 1, the activity must not occur at all in the traces.\n    If the count is not provided, it defaults to 1.\n\n    Args:\n    ----\n        activity (int): The activity to be checked.\n        count (int, optional): The threshold at which the activity is considered absent.\n            Defaults to 1.\n\n    \"\"\"\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return (traces == self.activity).sum(dim=1) &lt; self.count\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExactlyConstraint","title":"<code>ExactlyConstraint</code>","text":"<p>               Bases: <code>ExistenceTemplateWithCount</code></p> <p>Constraint to check if an activity occurs exactly a certain number of times.</p> <p>This constraint states that a certain activity must occur exactly a certain number of times in the traces. It is defined by the activity to be checked and a count. The count specifies the exact number of occurrences of the activity in the traces. If the count is not provided, it defaults to 1.</p> <pre><code>activity (int): The activity to be checked.\ncount (int, optional): The exact number of occurrences of the activity in the\n    traces. Defaults to 1.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/exactly.py</code> <pre><code>class ExactlyConstraint(ExistenceTemplateWithCount):\n    \"\"\"Constraint to check if an activity occurs exactly a certain number of times.\n\n    This constraint states that a certain activity must occur exactly a certain number\n    of times in the traces.\n    It is defined by the activity to be checked and a count.\n    The count specifies the exact number of occurrences of the activity in the traces.\n    If the count is not provided, it defaults to 1.\n\n    Args:\n    ----\n        activity (int): The activity to be checked.\n        count (int, optional): The exact number of occurrences of the activity in the\n            traces. Defaults to 1.\n\n    \"\"\"\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return (traces == self.activity).sum(dim=1) == self.count\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExistenceConstraint","title":"<code>ExistenceConstraint</code>","text":"<p>               Bases: <code>ExistenceTemplateWithCount</code></p> <p>Constraint to check if an activity exists in traces.</p> <p>This constraint states that a certain activity must exist in the traces. It is defined by the activity to be checked and an optional count. It can also check if the activity exists with a specified count. The count specifies the minimum number of occurrences of the activity in the traces. If the count is not provided, it defaults to 1.</p> <pre><code>activity (int): The activity to be checked.\ncount (int, optional): The minimum number of occurrences of the activity in the\n    traces. Defaults to 1.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/existence.py</code> <pre><code>class ExistenceConstraint(ExistenceTemplateWithCount):\n    \"\"\"Constraint to check if an activity exists in traces.\n\n    This constraint states that a certain activity must exist in the traces.\n    It is defined by the activity to be checked and an optional count.\n    It can also check if the activity exists with a specified count.\n    The count specifies the minimum number of occurrences of the activity in the traces.\n    If the count is not provided, it defaults to 1.\n\n    Args:\n    ----\n        activity (int): The activity to be checked.\n        count (int, optional): The minimum number of occurrences of the activity in the\n            traces. Defaults to 1.\n\n    \"\"\"\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return (traces == self.activity).sum(dim=1) &gt;= self.count\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExistenceTemplate","title":"<code>ExistenceTemplate</code>","text":"<p>               Bases: <code>DeclareConstraint</code></p> <p>Base class for existence constraints.</p> <p>This class is used as a template for defining existence constraints in the Declare4Pylon library. It is not intended to be used directly, but rather as a base class for specific existence constraints.</p> Source code in <code>src/declare4pylon/constraints/existence/template.py</code> <pre><code>class ExistenceTemplate(DeclareConstraint):\n    \"\"\"Base class for existence constraints.\n\n    This class is used as a template for defining existence constraints in the\n    Declare4Pylon library.\n    It is not intended to be used directly, but rather as a base class for\n    specific existence constraints.\n    \"\"\"\n\n    def __init__(self, activity: int) -&gt; None:\n        \"\"\"Initialize the ExistenceTemplate with an activity.\n\n        Args:\n        ----\n            activity (int): The activity to be used in the existence constraint.\n\n        \"\"\"\n        self.activity = activity\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExistenceTemplate.__init__","title":"<code>__init__(activity)</code>","text":"<p>Initialize the ExistenceTemplate with an activity.</p> <pre><code>activity (int): The activity to be used in the existence constraint.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/template.py</code> <pre><code>def __init__(self, activity: int) -&gt; None:\n    \"\"\"Initialize the ExistenceTemplate with an activity.\n\n    Args:\n    ----\n        activity (int): The activity to be used in the existence constraint.\n\n    \"\"\"\n    self.activity = activity\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExistenceTemplateWithCount","title":"<code>ExistenceTemplateWithCount</code>","text":"<p>               Bases: <code>ExistenceTemplate</code></p> <p>Base class for existence constraints with a count.</p> <p>This class is used as a template for defining existence constraints in the Declare4Pylon library that require a count of occurrences. It is not intended to be used directly, but rather as a base class for specific existence constraints with a count.</p> Source code in <code>src/declare4pylon/constraints/existence/template.py</code> <pre><code>class ExistenceTemplateWithCount(ExistenceTemplate):\n    \"\"\"Base class for existence constraints with a count.\n\n    This class is used as a template for defining existence constraints in the\n    Declare4Pylon library that require a count of occurrences.\n    It is not intended to be used directly, but rather as a base class for\n    specific existence constraints with a count.\n    \"\"\"\n\n    def __init__(self, activity: int, count: int = 1) -&gt; None:\n        \"\"\"Initialize the ExistenceTemplateWithCount with an activity and count.\n\n        Args:\n        ----\n            activity (int): The activity to be used in the existence constraint.\n            count (int): The number of occurrences to be considered in the evaluation.\n                Default is 1.\n\n        Raises:\n        ------\n            ValueError: If count is not a positive integer.\n\n        \"\"\"\n        if count &lt;= 0:\n            msg = \"Count must be a positive integer.\"\n            raise ValueError(msg)\n        super().__init__(activity=activity)\n        self.count = count\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.ExistenceTemplateWithCount.__init__","title":"<code>__init__(activity, count=1)</code>","text":"<p>Initialize the ExistenceTemplateWithCount with an activity and count.</p> <pre><code>activity (int): The activity to be used in the existence constraint.\ncount (int): The number of occurrences to be considered in the evaluation.\n    Default is 1.\n</code></pre> <pre><code>ValueError: If count is not a positive integer.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/template.py</code> <pre><code>def __init__(self, activity: int, count: int = 1) -&gt; None:\n    \"\"\"Initialize the ExistenceTemplateWithCount with an activity and count.\n\n    Args:\n    ----\n        activity (int): The activity to be used in the existence constraint.\n        count (int): The number of occurrences to be considered in the evaluation.\n            Default is 1.\n\n    Raises:\n    ------\n        ValueError: If count is not a positive integer.\n\n    \"\"\"\n    if count &lt;= 0:\n        msg = \"Count must be a positive integer.\"\n        raise ValueError(msg)\n    super().__init__(activity=activity)\n    self.count = count\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.InitConstraint","title":"<code>InitConstraint</code>","text":"<p>               Bases: <code>ExistenceTemplate</code></p> <p>Constraint to check if an activity is the first occurrence in traces.</p> <p>This constraint states that a certain activity must be the first occurrence in the traces.</p> <p>If you want to check if the activity is the first occurrence skipping the first column (e.g. when the first column is the start-of-sequence (sos) activity), use the :class:<code>InitConstraintAfterSpecialToken</code> class.</p> <pre><code>activity (int): The activity to be used in the init constraint.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/init.py</code> <pre><code>class InitConstraint(ExistenceTemplate):\n    \"\"\"Constraint to check if an activity is the first occurrence in traces.\n\n    This constraint states that a certain activity must be the first occurrence in the\n    traces.\n\n    If you want to check if the activity is the first occurrence skipping the first\n    column (e.g. when the first column is the start-of-sequence (sos) activity), use the\n    :class:`InitConstraintAfterSpecialToken` class.\n\n    Args:\n    ----\n        activity (int): The activity to be used in the init constraint.\n\n    \"\"\"\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return _is_activity_at_column(\n            traces=traces,\n            activity=self.activity,\n            column=0,\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.InitConstraintAfterSpecialToken","title":"<code>InitConstraintAfterSpecialToken</code>","text":"<p>               Bases: <code>ExistenceTemplate</code></p> <p>Constraint to check if an activity is the first occurrence in traces.</p> <p>This constraint states that a certain activity must be the first occurrence in the traces. This constraint assumes that the first column of the traces is the start-of-sequence (sos) activity or another special token.</p> <p>If you want to check if the activity is the first occurrence without the special token, use the :class:<code>InitConstraint</code> class.</p> <pre><code>activity (int): The activity to be used in the init constraint.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/init.py</code> <pre><code>class InitConstraintAfterSpecialToken(ExistenceTemplate):\n    \"\"\"Constraint to check if an activity is the first occurrence in traces.\n\n    This constraint states that a certain activity must be the first occurrence in the\n    traces.\n    This constraint assumes that the first column of the traces is the start-of-sequence\n    (sos) activity or another special token.\n\n    If you want to check if the activity is the first occurrence without the special token, use\n    the :class:`InitConstraint` class.\n\n    Args:\n    ----\n        activity (int): The activity to be used in the init constraint.\n\n    \"\"\"\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return _is_activity_at_column(\n            traces=traces,\n            activity=self.activity,\n            column=1,\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.LastConstraint","title":"<code>LastConstraint</code>","text":"<p>               Bases: <code>ExistenceTemplate</code></p> <p>Constraint to check if an activity is the last occurrence in traces.</p> <p>This constraint states that a certain activity must be the last occurrence in the traces. It can also check if the last occurrence is followed by an end-of-sequence (eos) activity. The constraint can be used to enforce that the specified activity is the last occurrence in the traces, optionally followed by an eos activity. The constraint is defined by the activity to be checked, a padding value, and an optional eos value.</p> <pre><code>activity (int): The activity to be checked.\npad (int, optional): The padding value to ignore in the traces.\n    Defaults to 0.\neos (int | None, optional): If provided, the constraint checks if the last\n    occurrence is followed by the eos activity. Defaults to None.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/last.py</code> <pre><code>class LastConstraint(ExistenceTemplate):\n    \"\"\"Constraint to check if an activity is the last occurrence in traces.\n\n    This constraint states that a certain activity must be the last occurrence in the\n    traces.\n    It can also check if the last occurrence is followed by an end-of-sequence (eos)\n    activity.\n    The constraint can be used to enforce that the specified activity is the last\n    occurrence in the traces, optionally followed by an eos activity.\n    The constraint is defined by the activity to be checked, a padding value, and an\n    optional eos value.\n\n    Args:\n    ----\n        activity (int): The activity to be checked.\n        pad (int, optional): The padding value to ignore in the traces.\n            Defaults to 0.\n        eos (int | None, optional): If provided, the constraint checks if the last\n            occurrence is followed by the eos activity. Defaults to None.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        activity: int,\n        pad: int = 0,\n        eos: int | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize the LastConstraint with an activity, padding value, and eos value.\n\n        This constructor initializes the LastConstraint with the specified activity,\n        padding value, and eos value.\n        The padding values at the end of the traces are ignored when checking for the\n        last occurrence of the activity.\n\n        Args:\n        ----\n            activity (int): The activity to be checked.\n            pad (int, optional): The padding value to ignore in the traces.\n                Defaults to 0.\n            eos (int | None, optional): _description_. Defaults to None.\n                If provided, the constraint checks if the last occurrence is followed by\n                the eos activity.\n\n        \"\"\"\n        super().__init__(activity)\n        self.pad_value = pad\n        self.eos_value = eos\n\n    def _condition(\n        self,\n        traces: Int[torch.Tensor, \"batch activities\"],\n    ) -&gt; Bool[torch.Tensor, \" batch\"]:\n        # Check which indices are not padding\n        non_pad_indices = torch.nonzero(traces != self.pad_value)\n        row_indices, col_indices = non_pad_indices[:, 0], non_pad_indices[:, 1]\n\n        # Get the last non-padding index for each row\n        last_non_pad_index = torch.zeros(\n            traces.shape[0],\n            dtype=torch.long,\n        ).scatter_reduce(0, row_indices, col_indices, reduce=\"amax\", include_self=False)\n\n        # Set to -1 if the row is all padding\n        ignore_row = -1\n        last_non_pad_index[(traces != self.pad_value).sum(dim=1) == 0] = ignore_row\n\n        # Create the result tensor\n        result = torch.zeros(traces.shape[0], dtype=torch.bool)\n\n        for i, (last_index, row) in enumerate(\n            zip(last_non_pad_index, traces, strict=False),\n        ):\n            # Ignore rows that are all padding\n            if last_index == ignore_row:\n                continue\n\n            # Check if the last index is the activity\n            if self.eos_value is None:\n                result[i] = row[last_index] == self.activity\n\n            # Check if the second last index is the activity and the last index is the\n            # eos\n            else:\n                result[i] = (\n                    last_index &gt; 0 and row[last_index - 1] == self.activity and row[last_index] == self.eos_value\n                )\n\n        return result\n</code></pre>"},{"location":"declare4pylon/constraints/existence/#declare4pylon.constraints.existence.LastConstraint.__init__","title":"<code>__init__(activity, pad=0, eos=None)</code>","text":"<p>Initialize the LastConstraint with an activity, padding value, and eos value.</p> <p>This constructor initializes the LastConstraint with the specified activity, padding value, and eos value. The padding values at the end of the traces are ignored when checking for the last occurrence of the activity.</p> <pre><code>activity (int): The activity to be checked.\npad (int, optional): The padding value to ignore in the traces.\n    Defaults to 0.\neos (int | None, optional): _description_. Defaults to None.\n    If provided, the constraint checks if the last occurrence is followed by\n    the eos activity.\n</code></pre> Source code in <code>src/declare4pylon/constraints/existence/last.py</code> <pre><code>def __init__(\n    self,\n    activity: int,\n    pad: int = 0,\n    eos: int | None = None,\n) -&gt; None:\n    \"\"\"Initialize the LastConstraint with an activity, padding value, and eos value.\n\n    This constructor initializes the LastConstraint with the specified activity,\n    padding value, and eos value.\n    The padding values at the end of the traces are ignored when checking for the\n    last occurrence of the activity.\n\n    Args:\n    ----\n        activity (int): The activity to be checked.\n        pad (int, optional): The padding value to ignore in the traces.\n            Defaults to 0.\n        eos (int | None, optional): _description_. Defaults to None.\n            If provided, the constraint checks if the last occurrence is followed by\n            the eos activity.\n\n    \"\"\"\n    super().__init__(activity)\n    self.pad_value = pad\n    self.eos_value = eos\n</code></pre>"},{"location":"declare4pylon/constraints/relation/","title":"Relation","text":""},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.AlternatePrecedenceConstraint","title":"<code>AlternatePrecedenceConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>Each time B occurs in the process instance, it is preceded by A and no other B can recur in between.</p> Source code in <code>src/declare4pylon/constraints/relation/precedence/alternate_precedence.py</code> <pre><code>class AlternatePrecedenceConstraint(RelationTemplate):\n    \"\"\"Each time B occurs in the process instance, it is preceded by A and no other B can recur in between.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        rows = torch.ones(traces.shape[0], dtype=torch.bool)\n\n        b_positions = torch.where(traces == self.activity_b)\n\n        for i in range(b_positions[0].numel()):\n            row, col = b_positions[0][i], b_positions[1][i]\n            if not rows[row]:\n                continue\n            rows[row] = False\n\n            for j in reversed(range(col)):\n                if traces[row, j] == self.activity_b:\n                    break\n                if traces[row, j] == self.activity_a:\n                    rows[row] = True\n                    break\n\n        return rows\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.AlternateResponseConstraint","title":"<code>AlternateResponseConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>Each time A occurs in the process instance, then B occurs afterwards, before A recurs.</p> Source code in <code>src/declare4pylon/constraints/relation/response/alternate_response.py</code> <pre><code>class AlternateResponseConstraint(RelationTemplate):\n    \"\"\"Each time A occurs in the process instance, then B occurs afterwards, before A recurs.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        rows = torch.ones(traces.shape[0], dtype=torch.bool)\n        a_positions = torch.where(traces == self.activity_a)\n\n        for i in range(a_positions[0].numel()):\n            row, col = a_positions[0][i], a_positions[1][i]\n            if not rows[row]:\n                continue\n            rows[row] = False\n\n            for j in range(col + 1, traces.shape[1]):\n                if traces[row, j] == self.activity_b:\n                    rows[row] = True\n                    break\n                if traces[row, j] == self.activity_a:\n                    break\n\n        return rows\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.AlternateSuccessionConstraint","title":"<code>AlternateSuccessionConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>A and B occur if and only if the latter follows the former, and they alternate each other in the trace.</p> Source code in <code>src/declare4pylon/constraints/relation/succession/alternate_succession.py</code> <pre><code>class AlternateSuccessionConstraint(RelationTemplate):\n    \"\"\"A and B occur if and only if the latter follows the former, and they alternate each other in the trace.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_and(\n            AlternateResponseConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n            AlternatePrecedenceConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.ChainPrecedenceConstraint","title":"<code>ChainPrecedenceConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>Each time B occurs in the process instance, then A occurs immediately beforehand.</p> Source code in <code>src/declare4pylon/constraints/relation/precedence/chain_precedence.py</code> <pre><code>class ChainPrecedenceConstraint(RelationTemplate):\n    \"\"\"Each time B occurs in the process instance, then A occurs immediately beforehand.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        a_positions = torch.where(traces == self.activity_a)\n        b_positions = torch.where(traces == self.activity_b)\n\n        mask = torch.ones_like(traces, dtype=torch.bool)\n        mask[b_positions] = False\n        post_a_positions = [a_positions[0], torch.add(a_positions[1], +1)]\n        post_a_positions[0] = post_a_positions[0][post_a_positions[1] &lt; traces.shape[1]]\n        post_a_positions[1] = post_a_positions[1][post_a_positions[1] &lt; traces.shape[1]]\n        mask[post_a_positions] = True\n\n        return mask.all(dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.ChainResponseConstraint","title":"<code>ChainResponseConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>Each time A occurs in the process instance, then B occurs immediately afterwards.</p> Source code in <code>src/declare4pylon/constraints/relation/response/chain_response.py</code> <pre><code>class ChainResponseConstraint(RelationTemplate):\n    \"\"\"Each time A occurs in the process instance, then B occurs immediately afterwards.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        a_positions = torch.where(traces == self.activity_a)\n\n        b_positions = torch.where(traces == self.activity_b)\n\n        mask = torch.ones_like(traces, dtype=torch.bool)\n        mask[a_positions] = False\n        pre_b_positions = [b_positions[0], torch.add(b_positions[1], -1)]\n        pre_b_positions[0] = pre_b_positions[0][pre_b_positions[1] &gt;= 0]\n        pre_b_positions[1] = pre_b_positions[1][pre_b_positions[1] &gt;= 0]\n        mask[pre_b_positions] = True\n\n        return mask.all(dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.ChainSuccessionConstraint","title":"<code>ChainSuccessionConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>A and B occur in the process instance if and only if the latter immediately follows the former.</p> Source code in <code>src/declare4pylon/constraints/relation/succession/chain_succession.py</code> <pre><code>class ChainSuccessionConstraint(RelationTemplate):\n    \"\"\"A and B occur in the process instance if and only if the latter immediately follows the former.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_and(\n            ChainResponseConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n            ChainPrecedenceConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.CoExistenceConstraint","title":"<code>CoExistenceConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>A and B occur either both or none in the process instance.</p> Source code in <code>src/declare4pylon/constraints/relation/existence/co_existence.py</code> <pre><code>class CoExistenceConstraint(RelationTemplate):\n    \"\"\"A and B occur either both or none in the process instance.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        activity_a_is_present = torch.any(traces == self.activity_a, dim=1)\n        activity_b_is_present = torch.any(traces == self.activity_b, dim=1)\n        return torch.logical_or(\n            torch.logical_and(activity_a_is_present, activity_b_is_present),\n            torch.logical_and(\n                torch.logical_not(activity_a_is_present),\n                torch.logical_not(activity_b_is_present),\n            ),\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.PrecedenceConstraint","title":"<code>PrecedenceConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>B occurs in the process instance only if preceded by A.</p> Source code in <code>src/declare4pylon/constraints/relation/precedence/precedence.py</code> <pre><code>class PrecedenceConstraint(RelationTemplate):\n    \"\"\"B occurs in the process instance only if preceded by A.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        a_positions = torch.where(traces == self.activity_a)\n        b_positions = torch.where(traces == self.activity_b)\n\n        mask = torch.ones_like(traces, dtype=torch.bool)\n        mask[b_positions] = False\n        for i in range(traces.shape[0]):\n            a_row_positions = a_positions[1][a_positions[0] == i]\n            if a_row_positions.numel() &gt; 0:\n                mask[i, a_row_positions.min() :] = True\n\n        return mask.all(dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.RelationTemplate","title":"<code>RelationTemplate</code>","text":"<p>               Bases: <code>DeclareConstraint</code></p> <p>Base class for relation constraints.</p> <p>This class is used as a template for defining relation constraints in the Declare4Pylon library. It is not intended to be used directly, but rather as a base class for specific relation constraints.</p> Source code in <code>src/declare4pylon/constraints/relation/template.py</code> <pre><code>class RelationTemplate(DeclareConstraint):\n    \"\"\"Base class for relation constraints.\n\n    This class is used as a template for defining relation constraints in the\n    Declare4Pylon library.\n    It is not intended to be used directly, but rather as a base class for\n    specific relation constraints.\n    \"\"\"\n\n    def __init__(self, activity_a: int, activity_b: int) -&gt; None:\n        \"\"\"Initialize the RelationTemplate with two activities.\n\n        Args:\n        ----\n            activity_a (int): The first activity to be used in the relation constraint.\n            activity_b (int): The second activity to be used in the relation constraint.\n\n\n        \"\"\"\n        self.activity_a = activity_a\n        self.activity_b = activity_b\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.RelationTemplate.__init__","title":"<code>__init__(activity_a, activity_b)</code>","text":"<p>Initialize the RelationTemplate with two activities.</p> <pre><code>activity_a (int): The first activity to be used in the relation constraint.\nactivity_b (int): The second activity to be used in the relation constraint.\n</code></pre> Source code in <code>src/declare4pylon/constraints/relation/template.py</code> <pre><code>def __init__(self, activity_a: int, activity_b: int) -&gt; None:\n    \"\"\"Initialize the RelationTemplate with two activities.\n\n    Args:\n    ----\n        activity_a (int): The first activity to be used in the relation constraint.\n        activity_b (int): The second activity to be used in the relation constraint.\n\n\n    \"\"\"\n    self.activity_a = activity_a\n    self.activity_b = activity_b\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.RespondedExistenceConstraint","title":"<code>RespondedExistenceConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>If A occurs in the process instance, then B occurs as well.</p> Source code in <code>src/declare4pylon/constraints/relation/existence/responded_existence.py</code> <pre><code>class RespondedExistenceConstraint(RelationTemplate):\n    \"\"\"If A occurs in the process instance, then B occurs as well.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        activity_a_is_present = torch.any(traces == self.activity_a, dim=1)\n        activity_b_is_present = torch.any(traces == self.activity_b, dim=1)\n        return torch.logical_or(\n            torch.logical_not(activity_a_is_present),\n            torch.logical_and(activity_a_is_present, activity_b_is_present),\n        )\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.ResponseConstraint","title":"<code>ResponseConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>If A occurs in the process instance, then B occurs after A.</p> Source code in <code>src/declare4pylon/constraints/relation/response/response.py</code> <pre><code>class ResponseConstraint(RelationTemplate):\n    \"\"\"If A occurs in the process instance, then B occurs after A.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        a_positions = torch.where(traces == self.activity_a)\n        b_positions = torch.where(traces == self.activity_b)\n\n        mask = torch.ones_like(traces, dtype=torch.bool)\n        mask[a_positions] = False\n\n        for i in range(traces.shape[0]):\n            b_indices = b_positions[1][b_positions[0] == i]\n            if b_indices.numel() &gt; 0:\n                mask[i, : b_indices.max() + 1] = True\n\n        return mask.all(dim=1)\n</code></pre>"},{"location":"declare4pylon/constraints/relation/#declare4pylon.constraints.relation.SuccessionConstraint","title":"<code>SuccessionConstraint</code>","text":"<p>               Bases: <code>RelationTemplate</code></p> <p>A occurs if and only if it is followed by B. B occurs if and only if it is preceded by A.</p> Source code in <code>src/declare4pylon/constraints/relation/succession/succession.py</code> <pre><code>class SuccessionConstraint(RelationTemplate):\n    \"\"\"A occurs if and only if it is followed by B. B occurs if and only if it is preceded by A.\"\"\"\n\n    def _condition(self, traces: Int[torch.Tensor, \"batch activities\"]) -&gt; Bool[torch.Tensor, \" batch\"]:\n        return torch.logical_and(\n            ResponseConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n            PrecedenceConstraint(activity_a=self.activity_a, activity_b=self.activity_b)._condition(traces),  # noqa: SLF001\n        )\n</code></pre>"}]}